<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Service Mesh介绍]]></title>
    <url>%2Fservice-mesh-intro.html</url>
    <content type="text"><![CDATA[什么是Service MeshService Mesh中文翻译为“服务网格”, 单从技术名词来看让人摸不着头脑, 下面引用一段个人认为描述比较贴切的定义： A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware. —William Morgan 把上面这段定义拆开了看，首先service mesh is a infrastructure layer指明服务网格是基础设施层，其次handling service-to-service communication指明服务网格用于处理服务之间通信，responsible for delivery of requests through the complex topology of services这句话说的是服务网格的职责，负责在复杂服务拓扑下进行可靠的请求传递，service mesh is implemented as an array of lightweight network proxies指明服务网格的实现形式，通常被实现为网络代理，deployed alongside application code, without the application needing to be aware指明服务网格的部署方式，被部署在应用旁边而且对应用没有侵入性。 对这个定义总结一下: 本质：基础设施层 功能：请求传递/分发 部署形式：网络代理 特点：透明、无侵入 Service Mesh是网络模型吗服务网格作为网络模型是位于TCP/IP之上的抽象层，认为L3/L4网络能端到端地传递字节数据；在某些方面，服务网格类似TCP/IP，正如TCP抽象了在网络端点之间可靠地传递字节一样，服务网格抽象了服务之间可靠地传递请求，像TCP一样，服务网格不关心传递的内容及它们的编码方式。应用有个高层次目标（从A发送一些内容到B），服务网格的工作就像TCP一样，在帮助应用实现这个高层次目标的过程中处理任何失败。跟TCP不一样的是服务网格有一个更重要的目标：提供统一的、应用程序范围的点用于将可见性和控制引入到应用程序运行时。服务网格的明确目标是将服务通信从隐含不可见的基础设施层转移到“生态系统一级成员”角色中，在那里对其进行监控、管理和控制。 Service Mesh是做什么的在云原生应用中可靠地传递请求可能非常复杂，例如服务网格Linkerd通过一系列强大技术来管理这种复杂性：熔断器（circuit-breaking）、延迟感知负载均衡、最终一致性服务发现、超时、重试、降级等，所有这些功能需要协同工作。例如，当通过Linker向服务发出请求时，非常简单的事件时间线如下： Linkerd应用动态路由规则来确定需要请求的服务，请求应该路由到生产中的服务还是临时环境的服务？本地数据中心的服务还是云端的服务？正在测试服务的最新版本还是生产中已审查的旧版本？所有这些路由规则都是动态可配置的，可以全局应用也可以只应用于任意部分流量； 找到了正确的目标后，Linkerd从相关的服务发现中获取相应的实例池，如果这些信息与Linkerd在实际中观察到不同，Linkerd将决定该信任哪个信息源； Linkerd根据各种因素（例如最近请求的延迟）选择最有可能快速返回响应的实例； Linkerd尝试将请求发送到实例并记录结果延迟和响应类型； 如果实例已关闭、无响应或无法处理请求，Linkerd将在另一个实例上重试该请求（当且仅当该请求是幂等的） 如果一个实例总是返回错误，Linkerd会将其从负载均衡池中剔除，并在后期定期重试（例如实例遭遇暂时性故障） 如果请求超时，Linkerd将主动使请求失败而不是重试来进一步加重负载； Linkerd以度量（metric）和分布式跟踪（tracing）的方式捕获上述行为，并将其发送到一个集中的监控系统。 以上只是个简化的版本，Linkerd还可以启动和终止TLS、协议升级、动态转移流量以及多数据中心之间进行故障转移。需要注意的是，这些能力旨在提升应用程序的弹性。大型分布式系统，不管如何构建都有一个天然缺陷：它们为小的、局部的故障升级恶化为系统范围的灾难性故障提供了很多机会；当底层系统接近极限时，服务网格必须设计为能通过减少负载和快速失败来防止这种恶化升级。 为什么需要Service Mesh服务网格并不是要引入新功能而是原有功能实现位置的转移。过去Web应用必须自己管理服务之间通信的复杂性，服务网格模型的起源可以追溯到过去15年应用程序的演变过程。2000年代的Web应用是典型的三层结构：展示层、服务层、存储层，层之间的通信虽然复杂但可控毕竟范围只是在两层之间（没有“网格”，层之间的通信通过代码代码跳转实现）。但这种架构无法应对大规模海量业务。像Google、Netflix和Twitter这样的公司，面对巨大的流量需求，使用的是微服务架构：应用被划分成许多服务（称为“微服务”），这些微服务构成一个网络拓扑；在这些系统中，一个通用的通信层至关重要，通常采用胖客户端模式库（fat client）如：Twitter’s Finagle, Netflix’s Hystrix, and Google’s Stubby。从功能上看，Finagle, Stubby, and Hystrix也属于服务网格，只不过这些技术只针对自身的业务环境，需要使用特定编程语言和框架，但是功能上它们都是用于管理从服务到服务通信的专用基础设施，而且Finagle, Hystrix作为开源项目已被很多外部公司采用。在云原生时代，云原生模型将大量微服务与另外两个技术结合起来：容器（例如Docker）提供资源隔离和依赖管理能力，容器编排（例如Kubernetes）将底层硬件抽象为统一的资源池，这些技术的结合使应用具备更强的弹性（动态扩容及容错）。但是，在数百个服务或数千个实例以及任意时刻实例的重新编排，导致单个请求通过服务拓扑的路径可能会异常复杂，加之容器技术使每个服务的都可以使用不同编程语言编写，过去使用通信库的方法已不再可行。微服务通信的复杂性和重要性激发了对服务到服务通信专用基础架构层的需求，该层与应用程序代码分离，并能及时捕获底层环境的动态变化。这一层就是服务网格。 Service Mesh的未来在云原生生态系统中，虽然服务网格的采用在迅速增长，但未来仍是一个广泛且令人兴奋的领域值得探索。无服务器（Serverless）计算（如：Amazon’s Lambda）非常符合服务网格的命名和链接模型并扩展了服务网格在云原生生态系统中的作用。在云原生环境中，服务标识和访问策略仍然非常初级，服务网格已经准备在这里扮演一个重要角色。最后，服务网格将继续深入底层基础设施。就像linker从Finagle演变而来一样，服务网格将作为一个独立的处于用户空间的服务代理继续发展。 总结服务网格是云原生技术栈的关键组件。通过将服务之间通信（Service To Service）能力下沉到基层设施层，为微服务架构提供弹性通信、流量管理、安全、可观测性等能力，使开发者从管理网络通信复杂性这种繁琐工作中解脱出来，聚焦更具业务价值、更快交付能力的事情。未来，随着无服务器（Serverless）技术的发展，进一步将与业务无关的能力（如弹性扩缩容、路由、事件驱动等）下沉到基础设施层，开发者只需要关注业务实现，云计算厂商也能真正做到按使用计费而不是当前按容量和时间计费。 参考What’s a service mesh? And why do I need one?]]></content>
      <categories>
        <category>Cloud Native</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElastAlert实践]]></title>
    <url>%2Felast-alert.html</url>
    <content type="text"><![CDATA[IntroductionElastAlert是一个对ES中数据变更、异常、突增或符合某种模式数据进行通知报警的简单框架，出自Yelp工程团队。 Installation(Online)ElastAler基于Python开发，依赖大量第三方Python开发包，为了高效管理依赖包避免不同版本导致的兼容问题，强烈建议(此处省略一万字吐槽…)使用Virtualenv创建隔离的虚拟环境来安装部署使用ElastAlert。 Pip123首先下载并安装pip，pip为Python包管理工具$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py$ python get-pip.py Virtualenv123456用pip安装virtualevn$ pip install virtualenv创建Python隔离的虚拟环境并激活$ virtualenv .venv$ source .venv/bin/activate ElastAlert12345678910111213141516下载elastalert、安装elastalert依赖包、安装elastalert$ git clone https://github.com/Yelp/elastalert$ cd elastalert/$ pip install -r requirements.txt$ python setup.py installelastalert默认安装最新版本Elasticsearch Client（7.0），可以选择安装其他版本Elasticsearch Client（ElastAler支持所有ES版本）安装Elasticsearch Client（5.0+）$ pip install &quot;elasticsearch&gt;=5.0.0&quot;安装Elasticsearch Client（2.X）$ pip install &quot;elasticsearch&lt;3.0.0&quot;安装Elasticsearch Client（1.5）$ pip install &quot;elasticsearch==1.5.0&quot;具体使用哪个版本Elasticsearch Client由使用的ES版本决定 以上是在线环境下（联网）安装elastalert，所有依赖包都通过网络下载安装，相对来说比较简单。而实际应用中线上环境或内网环境为了安全都进行了网络隔离，无法直接访问外网也就没法在线安装，下面介绍离线场景下如何安装。 Installation(Offline)大部分情况下，服务器都是跟公网隔离的，下面介绍如何在离线情况下安装ElastAlert Python大部分Linux操作系统都自带Python，为了部署方便并兼容未提前安装Python的环境，一般ElastAlert打包部署时会自带Python环境 12345678下载Python源码包$ curl --location --output Python-2.7.9.tgz https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz解压、编译、安装Python（这里使用2.7版本）$ tar -zxvf Python-2.7.9.tgz$ cd Python-2.7.9$ ./configure --prefix=/usr/local/python-2.7.9(设置安装目录)make &amp;&amp; make install Virtualenv123456789101112131415使用本地文件安装Virtualevn先将源码下载到本地$ curl --location --output virtualenv-X.X.X.tar.gz https://github.com/pypa/virtualenv/tarball/X.X.X将源码包上传到服务器、解压、创建隔离虚拟环境$ tar xvfz virtualenv-X.X.X.tar.gz$ cd pypa-virtualenv-YYYYYY$ python virtualenv.py myVEvirtualevn自动将pip、setuptool、wheel安装到虚拟隔离环境中激活虚拟隔离环境$ source ./myVE/bin/activate退出虚拟隔离环境$ deactivate ElastAlert1234下载elastalert源码到本地$ curl --location --output elastalert-0.1.39.tar.gz https://codeload.github.com/Yelp/elastalert/tar.gz/v0.1.39$ tar xvfz elastalert-0.1.39.tar.gz$ cd elastalert-0.1.39/ 12345下载所有elastalert依赖包到本地$ mkdir dependencies$ pip download -r requirements.txt -d &quot;./dependencies&quot;$ tar cvfz dependencies.tar.gz dependencies将elastalert源码包、依赖包上传到服务器 12345678910在服务器上安装elastalet依赖包$ tar zxvf dependencies.tar.gz$ cd dependencies$ pip install * -f ./ --no-index安装过程中可能出现依赖包OS环境不兼容问题例如通过Mac机器下载的依赖包，无法安装在linux上，出现这种情况需要手动从https://pypi.org/下载linux版本依赖包进行替换重新安装即可举例Mac：cffi-1.12.3-cp27-cp27m-macosx_10_6_intel.whlLinux：cffi-1.12.3-cp27-cp27m-manylinux1_x86_64.whl 1234安装elastalert$ tar xvfz elastalert-0.1.39.tar.gz$ cd elastalert-0.1.39/$ python setup.py install Config1234567891011配置ElastAlert配置文件$ cp config.yaml.example config.yaml$ vim config.yamlrules_folder：规则文件夹run_every：运行频率buffer_time：延迟时间es_host：es访问地址es_port：es访问端口配置特定规则的配置文件（详见下面）$ vim example_rules/example_frequency.yaml Usage 创建Index123456789101112ElastAlert在运行过程中需要将查询和报警原始信息存储到ES中，便于审计，调试及故障恢复（失败时可以重试）首先创建保存ElastAlert运行时信息的Index$ elastalert-create-indexElastic Version: 1.5.2Reading Elastic 5 index mappings:Reading index mapping &apos;es_mappings/5/silence.json&apos;Reading index mapping &apos;es_mappings/5/elastalert_status.json&apos;Reading index mapping &apos;es_mappings/5/elastalert.json&apos;Reading index mapping &apos;es_mappings/5/past_elastalert.json&apos;Reading index mapping &apos;es_mappings/5/elastalert_error.json&apos;New index elastalert_status createdDone! 创建规则12345678910111213141516# 使用example_rules/example_frequency.yaml作为模版es_host: elasticsearch.example.comes_port: 14900name: Example rule（规则名）type: frequency（规则类型，内置支持多种规则类型，同时支持自定义规则类型）index: logstash-*（监控的Index，支持通配符）num_events: 50timeframe:（查询时间段） hours: 4filter:（查询条件）- term: some_field: &quot;some_value&quot;alert:（报警方式）- &quot;email&quot;email:- &quot;elastalert@example.com&quot; 测试规则12345678$ elastalert-test-rule example_rules/example_frequency.yamlSuccessfully loaded Example ruleINFO:elastalert:Queried rule Example rule from 2019-10-25 16:01 CST to 2019-05-07 16:16 CST: 0 / 0 hitsINFO:elastalert:Queried rule Example rule from 2019-10-25 16:16 CST to 2019-05-07 16:31 CST: 0 / 0 hitsINFO:elastalert:Queried rule Example rule from 2019-10-25 16:31 CST to 2019-05-07 16:46 CST: 0 / 0 hits...elastalert_status - &#123;&apos;hits&apos;: 0, &apos;matches&apos;: 0, &apos;@timestamp&apos;: datetime.datetime(2019, 10, 25, 12, 4, 2, 46856, tzinfo=tzutc()), &apos;rule_name&apos;: &apos;Example rule&apos;, &apos;starttime&apos;: datetime.datetime(2019, 10, 25, 8, 1, 37, 361544, tzinfo=tzutc()), &apos;endtime&apos;: datetime.datetime(2019, 10, 25, 12, 4, 1, 361544, tzinfo=tzutc()), &apos;time_taken&apos;: 0.6194741725921631&#125; 运行规则12345直接通过命令行调用Python执行$ python -m elastalert.elastalert --verbose --rule example_frequency.yamlINFO:elastalert:Queried rule Example rule from 2019-05-07 19:56 CST to 2019-05-07 20:11 CST: 0 / 0 hitsINFO:elastalert:Ran Example rule from 2019-05-07 19:56 CST to 2019-05-07 20:11 CST: 0 query hits (0 already seen), 0 matches, 0 alerts sentINFO:elastalert:Sleeping for 59.59002 seconds 还可以通过Supervisor作为daemon进程运行 Problems 执行elastalert报错1ImportError: failed to find libmagic. Check your installation 12原因：缺少依赖包python-magic-bin解决方法：pip install python-magic-bin==0.4.14 执行elastalert报错123456789101112131415161718192021INFO:elastalert:Starting upTraceback (most recent call last): File &quot;/home/users/renjie07/Env/python2.7/python2.7/lib/python2.7/runpy.py&quot;, line 162, in _run_module_as_main &quot;__main__&quot;, fname, loader, pkg_name) File &quot;/home/users/renjie07/Env/python2.7/python2.7/lib/python2.7/runpy.py&quot;, line 72, in _run_code exec code in run_globals File &quot;/home/users/zhangjun22/elastalert/elastalert-0.1.39/elastalert/elastalert.py&quot;, line 1929, in &lt;module&gt; sys.exit(main(sys.argv[1:])) File &quot;/home/users/zhangjun22/elastalert/elastalert-0.1.39/elastalert/elastalert.py&quot;, line 1925, in main client.start() File &quot;/home/users/zhangjun22/elastalert/elastalert-0.1.39/elastalert/elastalert.py&quot;, line 1106, in start self.run_all_rules() File &quot;/home/users/zhangjun22/elastalert/elastalert-0.1.39/elastalert/elastalert.py&quot;, line 1158, in run_all_rules self.send_pending_alerts() File &quot;/home/users/zhangjun22/elastalert/elastalert-0.1.39/elastalert/elastalert.py&quot;, line 1534, in send_pending_alerts pending_alerts = self.find_recent_pending_alerts(self.alert_time_limit) File &quot;/home/users/zhangjun22/elastalert/elastalert-0.1.39/elastalert/elastalert.py&quot;, line 1526, in find_recent_pending_alerts size=1000) File &quot;/home/users/zhangjun22/elastalert/virtualenv-16.0.0/myEnv/lib/python2.7/site-packages/elasticsearch/client/utils.py&quot;, line 84, in _wrapped return func(*args, params=params, **kwargs)TypeError: search() got an unexpected keyword argument &apos;doc_type&apos; 1234原因：Python Elasticsearch SDK版本不兼容，默认elasticsearch&gt;=7.0.0，使用最新版本解决：下载elasticsearch==1.5.0版本并安装pip download elasticsearch==1.5.0 -d &quot;./dependencies&quot;pip install elasticsearch-1.5.0-py2.py3-none-any.whl -f ./ --no-index References pip Virtualenv Mac Virtualenv ImportError: failed to find libmagic Installing python package without internet]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>ElastAlert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍]]></title>
    <url>%2Fintro.html</url>
    <content type="text"><![CDATA[记录个人生活、工作方方面面，点点滴滴~~ 技术领域分布式系统云原生大数据物联网生活旅游理财]]></content>
      <categories>
        <category>Distributed System</category>
        <category>Cloud Native</category>
        <category>Big Data</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>Distributed System</tag>
        <tag>Cloud Native</tag>
        <tag>Big Data</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
</search>
